// Code generated by protoc-gen-go-lite. DO NOT EDIT.
// protoc-gen-go-lite version:
// source: opentelemetry/proto/common/v1/common.proto

package opentelemetry_proto_common_v1

import (
	json "github.com/aperturerobotics/protobuf-go-lite/json"
)

// Copyright 2019, OpenTelemetry Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// AnyValue is used to represent any type of attribute value. AnyValue may contain a
// primitive value such as a string or integer or it may contain an arbitrary nested
// object containing arrays, key-value lists and primitives.
type AnyValue struct {
	unknownFields []byte
	// The value is one of the listed fields. It is valid for all values to be unspecified
	// in which case this AnyValue is considered to be "empty".
	//
	// Types that are assignable to Value:
	//
	//	*AnyValue_StringValue
	//	*AnyValue_BoolValue
	//	*AnyValue_IntValue
	//	*AnyValue_DoubleValue
	//	*AnyValue_ArrayValue
	//	*AnyValue_KvlistValue
	//	*AnyValue_BytesValue
	Value isAnyValue_Value `protobuf_oneof:"value"`
}

func (x *AnyValue) Reset() {
	*x = AnyValue{}
}

func (*AnyValue) ProtoMessage() {}

func (m *AnyValue) GetValue() isAnyValue_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (x *AnyValue) GetStringValue() string {
	if x, ok := x.GetValue().(*AnyValue_StringValue); ok {
		return x.StringValue
	}
	return ""
}

func (x *AnyValue) GetBoolValue() bool {
	if x, ok := x.GetValue().(*AnyValue_BoolValue); ok {
		return x.BoolValue
	}
	return false
}

func (x *AnyValue) GetIntValue() int64 {
	if x, ok := x.GetValue().(*AnyValue_IntValue); ok {
		return x.IntValue
	}
	return 0
}

func (x *AnyValue) GetDoubleValue() float64 {
	if x, ok := x.GetValue().(*AnyValue_DoubleValue); ok {
		return x.DoubleValue
	}
	return 0
}

func (x *AnyValue) GetArrayValue() *ArrayValue {
	if x, ok := x.GetValue().(*AnyValue_ArrayValue); ok {
		return x.ArrayValue
	}
	return nil
}

func (x *AnyValue) GetKvlistValue() *KeyValueList {
	if x, ok := x.GetValue().(*AnyValue_KvlistValue); ok {
		return x.KvlistValue
	}
	return nil
}

func (x *AnyValue) GetBytesValue() []byte {
	if x, ok := x.GetValue().(*AnyValue_BytesValue); ok {
		return x.BytesValue
	}
	return nil
}

type isAnyValue_Value interface {
	isAnyValue_Value()
}

type AnyValue_StringValue struct {
	StringValue string `protobuf:"bytes,1,opt,name=string_value,json=stringValue,proto3,oneof"`
}

type AnyValue_BoolValue struct {
	BoolValue bool `protobuf:"varint,2,opt,name=bool_value,json=boolValue,proto3,oneof"`
}

type AnyValue_IntValue struct {
	IntValue int64 `protobuf:"varint,3,opt,name=int_value,json=intValue,proto3,oneof"`
}

type AnyValue_DoubleValue struct {
	DoubleValue float64 `protobuf:"fixed64,4,opt,name=double_value,json=doubleValue,proto3,oneof"`
}

type AnyValue_ArrayValue struct {
	ArrayValue *ArrayValue `protobuf:"bytes,5,opt,name=array_value,json=arrayValue,proto3,oneof"`
}

type AnyValue_KvlistValue struct {
	KvlistValue *KeyValueList `protobuf:"bytes,6,opt,name=kvlist_value,json=kvlistValue,proto3,oneof"`
}

type AnyValue_BytesValue struct {
	BytesValue []byte `protobuf:"bytes,7,opt,name=bytes_value,json=bytesValue,proto3,oneof"`
}

func (*AnyValue_StringValue) isAnyValue_Value() {}

func (*AnyValue_BoolValue) isAnyValue_Value() {}

func (*AnyValue_IntValue) isAnyValue_Value() {}

func (*AnyValue_DoubleValue) isAnyValue_Value() {}

func (*AnyValue_ArrayValue) isAnyValue_Value() {}

func (*AnyValue_KvlistValue) isAnyValue_Value() {}

func (*AnyValue_BytesValue) isAnyValue_Value() {}

// ArrayValue is a list of AnyValue messages. We need ArrayValue as a message
// since oneof in AnyValue does not allow repeated fields.
type ArrayValue struct {
	unknownFields []byte
	// Array of values. The array may be empty (contain 0 elements).
	Values []*AnyValue `protobuf:"bytes,1,rep,name=values,proto3" json:"values,omitempty"`
}

func (x *ArrayValue) Reset() {
	*x = ArrayValue{}
}

func (*ArrayValue) ProtoMessage() {}

func (x *ArrayValue) GetValues() []*AnyValue {
	if x != nil {
		return x.Values
	}
	return nil
}

// KeyValueList is a list of KeyValue messages. We need KeyValueList as a message
// since `oneof` in AnyValue does not allow repeated fields. Everywhere else where we need
// a list of KeyValue messages (e.g. in Span) we use `repeated KeyValue` directly to
// avoid unnecessary extra wrapping (which slows down the protocol). The 2 approaches
// are semantically equivalent.
type KeyValueList struct {
	unknownFields []byte
	// A collection of key/value pairs of key-value pairs. The list may be empty (may
	// contain 0 elements).
	// The keys MUST be unique (it is not allowed to have more than one
	// value with the same key).
	Values []*KeyValue `protobuf:"bytes,1,rep,name=values,proto3" json:"values,omitempty"`
}

func (x *KeyValueList) Reset() {
	*x = KeyValueList{}
}

func (*KeyValueList) ProtoMessage() {}

func (x *KeyValueList) GetValues() []*KeyValue {
	if x != nil {
		return x.Values
	}
	return nil
}

// KeyValue is a key-value pair that is used to store Span attributes, Link
// attributes, etc.
type KeyValue struct {
	unknownFields []byte
	Key           string    `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value         *AnyValue `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (x *KeyValue) Reset() {
	*x = KeyValue{}
}

func (*KeyValue) ProtoMessage() {}

func (x *KeyValue) GetKey() string {
	if x != nil {
		return x.Key
	}
	return ""
}

func (x *KeyValue) GetValue() *AnyValue {
	if x != nil {
		return x.Value
	}
	return nil
}

// InstrumentationScope is a message representing the instrumentation scope information
// such as the fully qualified name and version.
type InstrumentationScope struct {
	unknownFields []byte
	// An empty instrumentation scope name means the name is unknown.
	Name    string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Version string `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
	// Additional attributes that describe the scope. [Optional].
	// Attribute keys MUST be unique (it is not allowed to have more than one
	// attribute with the same key).
	Attributes             []*KeyValue `protobuf:"bytes,3,rep,name=attributes,proto3" json:"attributes,omitempty"`
	DroppedAttributesCount uint32      `protobuf:"varint,4,opt,name=dropped_attributes_count,json=droppedAttributesCount,proto3" json:"droppedAttributesCount,omitempty"`
}

func (x *InstrumentationScope) Reset() {
	*x = InstrumentationScope{}
}

func (*InstrumentationScope) ProtoMessage() {}

func (x *InstrumentationScope) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *InstrumentationScope) GetVersion() string {
	if x != nil {
		return x.Version
	}
	return ""
}

func (x *InstrumentationScope) GetAttributes() []*KeyValue {
	if x != nil {
		return x.Attributes
	}
	return nil
}

func (x *InstrumentationScope) GetDroppedAttributesCount() uint32 {
	if x != nil {
		return x.DroppedAttributesCount
	}
	return 0
}

// MarshalProtoJSON marshals the AnyValue message to JSON.
func (x *AnyValue) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if x.Value != nil {
		switch ov := x.Value.(type) {
		case *AnyValue_StringValue:
			s.WriteMoreIf(&wroteField)
			s.WriteObjectField("stringValue")
			s.WriteString(ov.StringValue)
		case *AnyValue_BoolValue:
			s.WriteMoreIf(&wroteField)
			s.WriteObjectField("boolValue")
			s.WriteBool(ov.BoolValue)
		case *AnyValue_IntValue:
			s.WriteMoreIf(&wroteField)
			s.WriteObjectField("intValue")
			s.WriteInt64(ov.IntValue)
		case *AnyValue_DoubleValue:
			s.WriteMoreIf(&wroteField)
			s.WriteObjectField("doubleValue")
			s.WriteFloat64(ov.DoubleValue)
		case *AnyValue_ArrayValue:
			s.WriteMoreIf(&wroteField)
			s.WriteObjectField("arrayValue")
			ov.ArrayValue.MarshalProtoJSON(s.WithField("arrayValue"))
		case *AnyValue_KvlistValue:
			s.WriteMoreIf(&wroteField)
			s.WriteObjectField("kvlistValue")
			ov.KvlistValue.MarshalProtoJSON(s.WithField("kvlistValue"))
		case *AnyValue_BytesValue:
			s.WriteMoreIf(&wroteField)
			s.WriteObjectField("bytesValue")
			s.WriteBytes(ov.BytesValue)
		}
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the AnyValue to JSON.
func (x *AnyValue) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the AnyValue message from JSON.
func (x *AnyValue) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
	s.ReadObject(func(key string) {
		switch key {
		default:
			s.Skip() // ignore unknown field
		case "string_value", "stringValue":
			s.AddField("string_value")
			ov := &AnyValue_StringValue{}
			x.Value = ov
			ov.StringValue = s.ReadString()
		case "bool_value", "boolValue":
			s.AddField("bool_value")
			ov := &AnyValue_BoolValue{}
			x.Value = ov
			ov.BoolValue = s.ReadBool()
		case "int_value", "intValue":
			s.AddField("int_value")
			ov := &AnyValue_IntValue{}
			x.Value = ov
			ov.IntValue = s.ReadInt64()
		case "double_value", "doubleValue":
			s.AddField("double_value")
			ov := &AnyValue_DoubleValue{}
			x.Value = ov
			ov.DoubleValue = s.ReadFloat64()
		case "array_value", "arrayValue":
			ov := &AnyValue_ArrayValue{}
			x.Value = ov
			if s.ReadNil() {
				ov.ArrayValue = nil
				return
			}
			ov.ArrayValue = &ArrayValue{}
			ov.ArrayValue.UnmarshalProtoJSON(s.WithField("array_value", true))
		case "kvlist_value", "kvlistValue":
			ov := &AnyValue_KvlistValue{}
			x.Value = ov
			if s.ReadNil() {
				ov.KvlistValue = nil
				return
			}
			ov.KvlistValue = &KeyValueList{}
			ov.KvlistValue.UnmarshalProtoJSON(s.WithField("kvlist_value", true))
		case "bytes_value", "bytesValue":
			s.AddField("bytes_value")
			ov := &AnyValue_BytesValue{}
			x.Value = ov
			ov.BytesValue = s.ReadBytes()
		}
	})
}

// UnmarshalJSON unmarshals the AnyValue from JSON.
func (x *AnyValue) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the ArrayValue message to JSON.
func (x *ArrayValue) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if len(x.Values) > 0 || s.HasField("values") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("values")
		s.WriteArrayStart()
		var wroteElement bool
		for _, element := range x.Values {
			s.WriteMoreIf(&wroteElement)
			element.MarshalProtoJSON(s.WithField("values"))
		}
		s.WriteArrayEnd()
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the ArrayValue to JSON.
func (x *ArrayValue) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the ArrayValue message from JSON.
func (x *ArrayValue) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
	s.ReadObject(func(key string) {
		switch key {
		default:
			s.Skip() // ignore unknown field
		case "values":
			s.AddField("values")
			if s.ReadNil() {
				x.Values = nil
				return
			}
			s.ReadArray(func() {
				if s.ReadNil() {
					x.Values = append(x.Values, nil)
					return
				}
				v := &AnyValue{}
				v.UnmarshalProtoJSON(s.WithField("values", false))
				if s.Err() != nil {
					return
				}
				x.Values = append(x.Values, v)
			})
		}
	})
}

// UnmarshalJSON unmarshals the ArrayValue from JSON.
func (x *ArrayValue) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the KeyValueList message to JSON.
func (x *KeyValueList) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if len(x.Values) > 0 || s.HasField("values") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("values")
		s.WriteArrayStart()
		var wroteElement bool
		for _, element := range x.Values {
			s.WriteMoreIf(&wroteElement)
			element.MarshalProtoJSON(s.WithField("values"))
		}
		s.WriteArrayEnd()
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the KeyValueList to JSON.
func (x *KeyValueList) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the KeyValueList message from JSON.
func (x *KeyValueList) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
	s.ReadObject(func(key string) {
		switch key {
		default:
			s.Skip() // ignore unknown field
		case "values":
			s.AddField("values")
			if s.ReadNil() {
				x.Values = nil
				return
			}
			s.ReadArray(func() {
				if s.ReadNil() {
					x.Values = append(x.Values, nil)
					return
				}
				v := &KeyValue{}
				v.UnmarshalProtoJSON(s.WithField("values", false))
				if s.Err() != nil {
					return
				}
				x.Values = append(x.Values, v)
			})
		}
	})
}

// UnmarshalJSON unmarshals the KeyValueList from JSON.
func (x *KeyValueList) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the KeyValue message to JSON.
func (x *KeyValue) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if x.Key != "" || s.HasField("key") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("key")
		s.WriteString(x.Key)
	}
	if x.Value != nil || s.HasField("value") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("value")
		x.Value.MarshalProtoJSON(s.WithField("value"))
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the KeyValue to JSON.
func (x *KeyValue) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the KeyValue message from JSON.
func (x *KeyValue) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
	s.ReadObject(func(key string) {
		switch key {
		default:
			s.Skip() // ignore unknown field
		case "key":
			s.AddField("key")
			x.Key = s.ReadString()
		case "value":
			if s.ReadNil() {
				x.Value = nil
				return
			}
			x.Value = &AnyValue{}
			x.Value.UnmarshalProtoJSON(s.WithField("value", true))
		}
	})
}

// UnmarshalJSON unmarshals the KeyValue from JSON.
func (x *KeyValue) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}

// MarshalProtoJSON marshals the InstrumentationScope message to JSON.
func (x *InstrumentationScope) MarshalProtoJSON(s *json.MarshalState) {
	if x == nil {
		s.WriteNil()
		return
	}
	s.WriteObjectStart()
	var wroteField bool
	if x.Name != "" || s.HasField("name") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("name")
		s.WriteString(x.Name)
	}
	if x.Version != "" || s.HasField("version") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("version")
		s.WriteString(x.Version)
	}
	if len(x.Attributes) > 0 || s.HasField("attributes") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("attributes")
		s.WriteArrayStart()
		var wroteElement bool
		for _, element := range x.Attributes {
			s.WriteMoreIf(&wroteElement)
			element.MarshalProtoJSON(s.WithField("attributes"))
		}
		s.WriteArrayEnd()
	}
	if x.DroppedAttributesCount != 0 || s.HasField("droppedAttributesCount") {
		s.WriteMoreIf(&wroteField)
		s.WriteObjectField("droppedAttributesCount")
		s.WriteUint32(x.DroppedAttributesCount)
	}
	s.WriteObjectEnd()
}

// MarshalJSON marshals the InstrumentationScope to JSON.
func (x *InstrumentationScope) MarshalJSON() ([]byte, error) {
	return json.DefaultMarshalerConfig.Marshal(x)
}

// UnmarshalProtoJSON unmarshals the InstrumentationScope message from JSON.
func (x *InstrumentationScope) UnmarshalProtoJSON(s *json.UnmarshalState) {
	if s.ReadNil() {
		return
	}
	s.ReadObject(func(key string) {
		switch key {
		default:
			s.Skip() // ignore unknown field
		case "name":
			s.AddField("name")
			x.Name = s.ReadString()
		case "version":
			s.AddField("version")
			x.Version = s.ReadString()
		case "attributes":
			s.AddField("attributes")
			if s.ReadNil() {
				x.Attributes = nil
				return
			}
			s.ReadArray(func() {
				if s.ReadNil() {
					x.Attributes = append(x.Attributes, nil)
					return
				}
				v := &KeyValue{}
				v.UnmarshalProtoJSON(s.WithField("attributes", false))
				if s.Err() != nil {
					return
				}
				x.Attributes = append(x.Attributes, v)
			})
		case "dropped_attributes_count", "droppedAttributesCount":
			s.AddField("dropped_attributes_count")
			x.DroppedAttributesCount = s.ReadUint32()
		}
	})
}

// UnmarshalJSON unmarshals the InstrumentationScope from JSON.
func (x *InstrumentationScope) UnmarshalJSON(b []byte) error {
	return json.DefaultUnmarshalerConfig.Unmarshal(b, x)
}
